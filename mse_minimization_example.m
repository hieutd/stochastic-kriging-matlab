% Script file: 
%    mse_minimization_example.m

% Purpose: 
%   This script give an example of the minimization process carried
%   on the Mean Squared Error surface generated by Stochastic Kriging. The
%   stochastic process used to generate the data is the Branin function with
%   standard normal error terms. The minimization process ultilize Simulated
%   Annealing on the parameter space in a divide-and-conquer fashion.

% Record of revisions
%   Date        Programmer      Description of change
%   ========    ==========      =========================================
%   11/06/09    hieutd          Original code
%   11/06/13    hieutd          Added option to re-run evaluation after
%                               each step
%   11/06/20    hieutd          Added options to run fmincon with different
%                               algorithm

% Define variables:
%   k: [1*1] - initial number of design points
%   d: [1*1] - number of dimensions of the parameter's space
%   maxX, minX: [1*d] - parameter upper bound and lower bound vector, respectively
%   X: [k*d] - design set
%   threshold: [1*1] - minimum accepted value of MSE (must be negative)
%   n: number of replication to generate the random error
%   Y: design values
%   Vhat: kriging variances at design points

clc; clear all; close all;

%% Initial values
%maxX = [1.9 1.1]; minX = [-1.9 -1.1];
maxX = [10 15]; minX = [-5 0];
d = size(minX, 2);
k = 10;
threshold = -10;
n = repmat(10, [k,1]);

t_check = false;

%% Sample the space: using Latin Hypercube Sampling
% Co = lhsdesign(k, 2);   % coeff generated by LHS to be used for params generation
% 
% min = repmat(minX, [k 1]);
% max = repmat(maxX, [k 1]);
% X = min + (max - min).*Co;
X = lhs(k, maxX, minX);

%% Generate the initial design value set using Branin function
%[Y Vhat] = procBranin(X, n, 'norm');
[Y Vhat] = procBranin(X, n, 'norm');

%% while (exist value higher than threshold)
%   fit the model
%   find the optimum points using SA
%   update the design set and design value
round = 1;
while (~t_check)
    t_check = true;
    % fname = modelFitting(X, Y, Vhat, 0);
    fname = SKfiting(X, Y, Vhat, 'SKsetting');                
    
    % let user pick an option whether to re-rerun the fitting or to draw
    % the graph for visualization (only works with 2-dims params) or to
    % continue the the next round.
    loop = true;
    while loop == true
        disp('Press (1) to re-run the SK fiting using a different optimization algorithm')
        disp('  (2) to draw the vis2ualization (only for 3D data)')
        disp('  (3) to continue to the next round')
        user_entry = input('your choice: ');
                
        switch user_entry
            case 1
                disp('(0):interior-point (1):trust-region-reflective (2):active-set');
                algor_sel = input('Select the algorithm:');
                fname = modelFitting(X, Y, Vhat, algor_sel);

            case 2
                disp('Now drawing graph...');
                drawGraph(fname, maxX, minX, X, Y); 
%                 % Use mesh-grid function to generate the prediction points
%                 K = 50; % K^2 is the number of prediction points, which 
%                         % will be generated by meshgrid function
%                 [Xp Yp] = meshgrid(minX(1):((maxX(1) - minX(1))/(K-1)):maxX(1),...
%                     minX(2):((maxX(2) - minX(2))/(K-1)):maxX(2));
%                 XK = [reshape(Xp, [K^2 1]) reshape(Yp, [K^2 1])];
%                 
%                 [SK_gau MSE] = predictCal(XK, fname);
%                 
%                 SKp = reshape(SK_gau, [K K]);
%                 msep = reshape(MSE, [K K]);
%                 
%                 subplot(1, 2, 1);
%                 mesh(Xp, Yp, SKp, (SKp - SKp));
%                 hold on;
%                 scatter3(X(1:k,1), X(1:k,2), Y, 'filled');
%                 title('SK prediction surface','FontWeight', 'bold');
%                 
%                 subplot(1, 2, 2);
%                 surface(Xp, Yp, msep);
%                 title('SK surface with regard to predicted MSE','FontWeight', 'bold');
%                 colorbar;
                
            case 3
                loop = false;
                
            otherwise
                disp('invalid selection! \n')
        end
    end
    
    %div = 2^round;
    div = 2;
    fprintf('=========================================\n');
    fprintf('Round=%d \n', round);
    fprintf('Number of sub-spaces: %d \n',d^div);
    
    A=[];
    for i = 1:div^d
        fprintf('--------------------------------------\n');
        fprintf('subspace=%d \n', i);
        % generate the combination needed to iterate the whole subspaces
        res = i;
        com = [];
        for j = 1:d
            com = [mod(res, div) com];
            res = floor(res/div);
        end
        
        % calculate the lower bound --> upper bound
        lb = minX + com.*(maxX-minX)./(div);
        ub = lb + ones(1, d).*(maxX-minX)./(div);
       
        % calculate the optimum point using SA
%         init = lb + (ub-lb)./2;
%         loss = @(x) mseCal(x, fname);
%         
%         controls.ub = ub;
%         controls.lb = lb;
%         controls.nt = 90;
%         controls.functol = 0.1;
%         controls.paramtol = 0.01;
%         controls.maxEval = 20000;
%         controls.neps = 20;
%         [min fval] = samin(loss, init, controls)
        [min fval] = pMSE(fname, ub, lb, 'SASetting');
        if fval < threshold
            t_check = false;
            A = [A; min];
        end
    end
    k = size (A, 1);
    if (k>0)
        n = repmat(10, [k, 1]);
        [Y_a Vhat_a] = procBranin(A, n, 'norm');
        X = [X;A];
        Y = [Y;Y_a];
        Vhat = [Vhat; Vhat_a];
    end
    k = size (X, 1);
    round = round + 1;
end

% draw the SK_pred and the trueK surf to evaluate precision
% Use mesh-grid function to generate the prediction points

disp('MSE threshold reached. Now drawing graph...');
K = 50; % K^2 is the number of prediction points, which will be generated by meshgrid function
[Xp Yp] = meshgrid(minX(1):((maxX(1) - minX(1))/(K-1)):maxX(1),...
    minX(2):((maxX(2) - minX(2))/(K-1)):maxX(2));
XK = [reshape(Xp, [K^2 1]) reshape(Yp, [K^2 1])];

[SK_gau MSE] = predictCal(XK, fname);
 
% calculate the analytical values
n = repmat(2, [K^2,1]);
%[trueK dummmy] = procBranin(XK, n, 'none');
[trueK dummy] = procBranin(XK, n, 'none');

% reshape the results into graph-compatible form
trueKp = reshape(trueK, [K K]);
SKp = reshape(SK_gau, [K K]);
msep = reshape(MSE, [K K]);

% draw all graphs
subplot(2, 2, 1);
mesh(Xp, Yp, trueKp, (trueKp - trueKp));
title('Analytical surface','FontWeight', 'bold');

subplot(2, 2, 2);
mesh(Xp, Yp, SKp, (SKp - SKp));
hold on;
scatter3(X(1:k,1), X(1:k,2), Y, 'filled');
title('SK prediction surface','FontWeight', 'bold');

subplot(2, 2, 3);
surface(Xp, Yp, abs(SKp-trueKp));
title('SK surface with regard to analytical values','FontWeight', 'bold');
colorbar;

subplot(2, 2, 4);
surface(Xp, Yp, msep);
title('SK surface with regard to predicted MSE','FontWeight', 'bold');
colorbar;



